<html>
<head>
<style>
div { font-color: white;}
.first_div {
    text-decoration: none;
    color: black;
    font-size: 20px;
    display: block;
    background-color: #808080;
}
.second_div {
    text-decoration: none;
    color: black;
    font-size: 20px;
    display: block;
    background-color: #D0D0D0;
}

ul {
    border: 1px solid black;
}

li {
    text-align: center;
    border-bottom: 1px solid grey;
    display: block;
    color: #000;
    padding: 8px 0 8px 16px;
    text-decoration: none;

}
li:hover{
    background:#A5A5A5 ;
}

li:last-child {
    border-bottom: none;
}
</style>
</head>
<body>
<div class="first_div"> <h1 align=center > POST 9</h1> 	 </div>
<div class="second_div"> 
    <h3 align=center > Complete Post </h3> 
	In short: the web server issues a unique identifier to on his visit. The visitor must bring back that ID for him to be recognised next time around. This identifier also allows the server to properly segregate objects owned by one session against that of another. If is: If is: Once he's on the service mode and on the groove, the servlet will work on the requests from all other clients.Why isn't it a good idea to have one instance per client? Think about this: Will you hire one pizza guy for every order that came? Do that and you'd be out of business in no time. It comes with a small risk though. Remember: this single guy holds all the order information in his pocket: so if you're not cautious about, he may end up giving the wrong order to a certain client.
  
</div> 
<div class="second_div"> 
<h3 align=center >Top 10 Relevant posts </h3>
</div>

<ul>
  
  <li><p> LINK: <a href="https://en.wikipedia.org/wiki/Java_(programming_language)">https://en.wikipedia.org/wiki/Java_(programming_language)</a> </p> <p>Java Servlet technology provides Web developers with a simple, consistent mechanism for extending the functionality of a Web server and for accessing existing business systems. Servlets are server-side Java EE components that generate responses (typically HTML pages) to requests (typically HTTP requests) from clients. A servlet can almost be thought of as an applet that runs on the server side without a face.
 </p></li>

  <li> <p> LINK: <a href="https://en.wikibooks.org/wiki/Java_Programming/Client_Server">https://en.wikibooks.org/wiki/Java_Programming/Client_Server</a> </p> <p>The following is the client class for the above server:</p></li>
  
  <li><p> LINK: <a href="https://en.wikipedia.org/wiki/Java_(programming_language)">https://en.wikipedia.org/wiki/Java_(programming_language)</a> </p> <p>The Hello class extends the GenericServlet class; the GenericServlet class provides the interface for the server to forward requests to the servlet and control the servlet's lifecycle.</p></li>

  <li> <p> LINK: <a href="https://en.wikibooks.org/wiki/Java_Programming/JavaSpaces">https://en.wikibooks.org/wiki/Java_Programming/JavaSpaces</a> </p> <p>The lookup service is described in theÂ : Jini Lookup Service Specification (reggie). This service interface defines all operations that are possible on the lookup service. Clients locate services by requesting with a lookup server that implements a particular interface. Client asks the lookup server for all services that implement the particular service interface. The lookup service returns service objects for all registered services that implement the given interface. The client may invoke methods on that object in order to interact directly with the server.</p></li>

  <li><p> LINK: <a href="https://en.wikibooks.org/wiki/Java_Programming/Client_Server">https://en.wikibooks.org/wiki/Java_Programming/Client_Server</a> </p> <p>A client code for a server/service is usually an API that a user application uses to interface to the server. With the help of a client API the user application does not have to know how to connect to the server to get services.</p> </li>

  <li> <p> LINK: <a href="https://en.wikibooks.org/wiki/Java_Programming/Q%26A">https://en.wikibooks.org/wiki/Java_Programming/Q%26A</a> </p> <p>If you need to call methods between different language environments, use CORBA. With CORBA a Java client can call C++ server and/or a C++ client can call a Java server. With RMI that can not be done.
</p> </li>

  <li><p> LINK: <a href="https://en.wikibooks.org/wiki/Java_Programming/Print_version">https://en.wikibooks.org/wiki/Java_Programming/Print_version</a> </p> <p>Platform independent Java is, however, very successful with server side applications, such as web services, servlets, or Enterprise JavaBeans.
</p></li>

  <li><p> LINK: <a href="https://en.wikibooks.org/wiki/Java_Programming/Java_Overview">https://en.wikibooks.org/wiki/Java_Programming/Java_Overview</a> </p> <p>Platform independent Java is, however, very successful with server side applications, such as web services, servlets, or Enterprise JavaBeans.</p></li>

  <li><p> LINK: <a href="https://en.wikibooks.org/wiki/Java_Programming/Remote_Method_Invocation">https://en.wikibooks.org/wiki/Java_Programming/Remote_Method_Invocation</a><p>The remote method invocation goes through a STUB on the client side and a so called SKELETON on the server side.</p> </li>

  <li><p> LINK: <a href="https://en.wikibooks.org/wiki/Java_Programming/Remote_Method_Invocation">https://en.wikibooks.org/wiki/Java_Programming/Remote_Method_Invocation</a> </p> <p>RMI is defined to use only with the Java platform. If you need to call methods between different language environments, use CORBA. With CORBA a Java client can call C++ server and/or a C++ client can call a Java server. With RMI that can not be done.</p> </li>
  
</ul>
</body>	