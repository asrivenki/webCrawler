<html>
<head>
<style>
div { font-color: white;}
.first_div {
    text-decoration: none;
    color: black;
    font-size: 20px;
    display: block;
    background-color: #808080;
}
.second_div {
    text-decoration: none;
    color: black;
    font-size: 20px;
    display: block;
    background-color: #D0D0D0;
}

ul {
    border: 1px solid black;
}

li {
    text-align: center;
    border-bottom: 1px solid grey;
    display: block;
    color: #000;
    padding: 8px 0 8px 16px;
    text-decoration: none;

}
li:hover{
    background:#A5A5A5 ;
}

li:last-child {
    border-bottom: none;
}
</style>
</head>
<body>
<div class="first_div"> <h1 align=center > POST 10</h1> 	 </div>
<div class="second_div"> 
    <h3 align=center > Complete Post </h3> 
	A safe way is to serialize the object, then deserialize.This ensures everything is a brand new reference.about how to do this efficiently. Caveats: It's possible for classes to override serialization such that new instances are created, e.g. for singletons.Also this of course doesn't work if your classes aren't Serializable.
  
</div> 

<div class="second_div"> 
<h3 align=center >Top 10 Relevant posts </h3>
</div>

<ul>
  
  <li><p> LINK: <a href="https://en.wikibooks.org/wiki/Object_Oriented_Programming">https://en.wikibooks.org/wiki/Object_Oriented_Programming</a> </p> <p>At least in Java, a constructor is unable to return a reference to an existing object—it MUST return a brand-new object. This can cause two problems—too many object instances, and identical objects that are duplicates—not the exact same object.
 </p></li>

  <li> <p> LINK: <a href="https://en.wikibooks.org/wiki/Java_Programming/Print_version">https://en.wikibooks.org/wiki/Java_Programming/Print_version</a> </p> <p>The java.lang.Object.clone() method returns a new object that is a copy of the current object. Classes must implement the marker interface java.lang.Cloneable to indicate that they can be cloned.</p></li>
  
  <li><p> LINK: <a href="https://en.wikibooks.org/wiki/Java_Programming/Classes,_Objects_and_Types">https://en.wikibooks.org/wiki/Java_Programming/Classes,_Objects_and_Types</a> </p> <p>The java.lang.Object.clone() method returns a new object that is a copy of the current object. Classes must implement the marker interface java.lang.Cloneable to indicate that they can be cloned.</p></li>

  <li> <p> LINK: <a href="https://en.wikibooks.org/wiki/Java_Programming/Print_version">https://en.wikibooks.org/wiki/Java_Programming/Print_version</a> </p> <p>Anonymous classes are most useful to create an instance of an interface or adapter class without needing a brand new class.</p></li>

  <li><p> LINK: <a href="https://en.wikibooks.org/wiki/Java_Programming/Nested_Classes">https://en.wikibooks.org/wiki/Java_Programming/Nested_Classes</a> </p> <p>Anonymous classes are most useful to create an instance of an interface or adapter class without needing a brand new class.</p> </li>

  <li> <p> LINK: <a href="https://en.wikibooks.org/wiki/Java_Programming/Print_version">https://en.wikibooks.org/wiki/Java_Programming/Print_version</a> </p> <p>Java has built-in support for serialization, using the Serializable interface; however, a class must first implement the Serializable interface.
</p> </li>

  <li><p> LINK: <a href="https://en.wikibooks.org/wiki/Java_Programming/Object_Lifecycle">https://en.wikibooks.org/wiki/Java_Programming/Object_Lifecycle</a> </p> <p>Java has built-in support for serialization, using the Serializable interface; however, a class must first implement the Serializable interface.
</p></li>

  <li><p> LINK: <a href="https://en.wikibooks.org/wiki/Java_Programming/Print_version">https://en.wikibooks.org/wiki/Java_Programming/Print_version</a> </p> <p>The name has not changed because the method has changed the reference and not the object itself. The behavior is the same as if the method was in-lined and the parameters were assigned to new variable names:</p></li>

  <li><p> LINK: <a href="https://en.wikibooks.org/wiki/Java_Programming/Methods">https://en.wikibooks.org/wiki/Java_Programming/Methods</a><p>The name has not changed because the method has changed the reference and not the object itself. The behavior is the same as if the method was in-lined and the parameters were assigned to new variable names:</p> </li>

  <li><p> LINK: <a href="https://en.wikibooks.org/wiki/Object_Oriented_Programming">https://en.wikibooks.org/wiki/Object_Oriented_Programming</a> </p> <p>Factories can also be used to inject user code into an "Unmodifiable" library. It is possible to save and restore a user object that implements some important functions of a library object. The library then uses that factory to get instances of the users object, and doesn't even know that the user has replaced a core component with completely new code.</p> </li>
  
</ul>
</body>	