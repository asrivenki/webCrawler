<html>
<head>
<style>
div { font-color: white;}
.first_div {
    text-decoration: none;
    color: black;
    font-size: 20px;
    display: block;
    background-color: #808080;
}
.second_div {
    text-decoration: none;
    color: black;
    font-size: 20px;
    display: block;
    background-color: #D0D0D0;
}

ul {
    border: 1px solid black;
}

li {
    text-align: center;
    border-bottom: 1px solid grey;
    display: block;
    color: #000;
    padding: 8px 0 8px 16px;
    text-decoration: none;

}
li:hover{
    background:#A5A5A5 ;
}

li:last-child {
    border-bottom: none;
}
</style>
</head>
<body>
<div class="first_div"> <h1 align=center > POST 3</h1> 	 </div>
<div class="second_div"> 
    <h3 align=center > Complete Post </h3> 
	Inheritance is when a 'class' derives from an existing 'class'.So if you have a Person class, then you have a Student class that extends Person, Student inherits all the things that Person has.There are some details around the access modifiers you put on the fields/methods in Person, but that's the basic idea.For example, if you have a private field on Person, Student won't see it because its private, and private fields are not visible to subclasses.Polymorphism deals with how the program decides which methods it should use, depending on what type of thing it has.If you have a Person, which has a read method, and you have a Student which extends Person, which has its own implementation of read, which method gets called is determined for you by the runtime, depending if you have a Person or a Student.It gets a bit tricky, but if you do something likePerson p = new Student();p.read();the read method on Student gets called.Thats the polymorphism in action.You can do that assignment because a Student is a Person, but the runtime is smart enough to know that the actual type of p is Student.Note that details differ among languages.You can do inheritance in javascript for example, but its completely different than the way it works in Java. 
</div> 
<div class="second_div"> 
<h3 align=center >Top 10 Relevant posts </h3>
</div>
<ul>
  
  <li><p> LINK: <a href="https://en.wikibooks.org/wiki/Java_Programming/Print_version">https://en.wikibooks.org/wiki/Java_Programming/Print_version</a> </p> <p>A best practice is to give fields private access and reserve public access to only the set of methods and final fields that define the class' public constants. This helps with encapsulation and information hiding, since it allows you to change the implementation of a class without affecting the consumers who use only the public API of the class. </p></li>
  <li> <p> LINK: <a href="https://en.wikibooks.org/wiki/Java_Programming/Keywords">https://en.wikibooks.org/wiki/Java_Programming/Keywords</a> </p> <p>A best practice is to give fields private access and reserve public access to only the set of methods and final fields that define the class' public constants. This helps with encapsulation and information hiding, since it allows you to change the implementation of a class without affecting the consumers who use only the public API of the class.</p></li>
  <li><p> LINK: <a href="https://en.wikibooks.org/wiki/Java_Programming/Print_version">https://en.wikibooks.org/wiki/Java_Programming/Print_version</a> </p> <p>Below is an example of an immutable public class named Length which maintains private instance fields named units and magnitude but provides a public constructor and two public accessor methods.</p></li>

  <li> <p> LINK: <a href="https://en.wikibooks.org/wiki/Java_Programming/Keywords">https://en.wikibooks.org/wiki/Java_Programming/Keywords</a> </p> <p>Below is an example of an immutable public class named Length which maintains private instance fields named units and magnitude but provides a public constructor and two public accessor methods.</p></li>

  <li><p> LINK: <a href="https://en.wikibooks.org/wiki/Java_Programming/Print_version">https://en.wikibooks.org/wiki/Java_Programming/Print_version</a> </p> <p> By default, a class will have all of its fields serialized when converted into a data stream (with transient fields being skipped). If additional handling is required beyond the default of writing all fields, you need to provide an implementation for methods:</p> </li>

  <li> <p> LINK: <a href="https://en.wikibooks.org/wiki/Java_Programming/Object_Lifecycle">https://en.wikibooks.org/wiki/Java_Programming/Object_Lifecycle</a> </p> <p>By default, a class will have all of its fields serialized when converted into a data stream (with transient fields being skipped). If additional handling is required beyond the default of writing all fields, you need to provide an implementation for methods:</p> </li>

  <li><p> LINK: <a href="https://en.wikibooks.org/wiki/Java_Programming/Print_version">https://en.wikibooks.org/wiki/Java_Programming/Print_version</a> </p> <p>This method is private since, like the fields point0 and point1, it is part of the internal implementation of the class and is not part of the external programming interface of the Distance class.</p></li>

  <li><p> LINK: <a href="https://en.wikibooks.org/wiki/Java_Programming/Understanding_a_Java_Program">https://en.wikibooks.org/wiki/Java_Programming/Understanding_a_Java_Program</a> </p> <p>This method is private since, like the fields point0 and point1, it is part of the internal implementation of the class and is not part of the external programming interface of the Distance class.</p></li>

  <li><p> LINK: <a href="https://en.wikibooks.org/wiki/Java_Programming/Print_version">https://en.wikibooks.org/wiki/Java_Programming/Print_version</a><p>List the fields and methods of this class that can be renamed without changing or even knowing the client classes.</p> </li>
  <li><p> LINK: <a href="https://en.wikibooks.org/wiki/Java_Programming/Scope">https://en.wikibooks.org/wiki/Java_Programming/Scope</a> </p> <p>List the fields and methods of this class that can be renamed without changing or even knowing the client classes.</p> </li>
  
</ul>
</body>	